"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encoder = function (ALPHABET, defaultEncoding) {
    if (defaultEncoding === void 0) { defaultEncoding = 'utf8'; }
    var ALPHABET_MAP = {};
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    for (var z = 0; z < ALPHABET.length; z += 1) {
        var x = ALPHABET.charAt(z);
        if (ALPHABET_MAP[x] !== undefined) {
            throw new TypeError("'" + x + "' is duplicate!");
        }
        ALPHABET_MAP[x] = z;
    }
    var encodeFromBuffer = function (source) {
        var sourceLen = source.length;
        if (sourceLen === 0) {
            return '';
        }
        var digits = [0];
        for (var i = 0; i < sourceLen; i += 1) {
            var carry = source[i];
            var digitsLen = digits.length;
            for (var j = 0; j < digitsLen; j += 1) {
                carry += digits[j] << 8;
                digits[j] = carry % BASE;
                carry = (carry / BASE) | 0;
            }
            while (carry > 0) {
                digits.push(carry % BASE);
                carry = (carry / BASE) | 0;
            }
        }
        var str = '';
        var lastSourceIndex = sourceLen - 1;
        for (var k = 0; source[k] === 0 && k < lastSourceIndex; k += 1) {
            str += LEADER;
        }
        for (var q = digits.length - 1; q >= 0; q -= 1) {
            str += ALPHABET[digits[q]];
        }
        return str;
    };
    var decodeToBuffer = function (encoded) {
        if (encoded.length === 0) {
            return Buffer.allocUnsafe(0);
        }
        var bytes = [0];
        var strLen = encoded.length;
        for (var i = 0; i < strLen; i += 1) {
            var value = ALPHABET_MAP[encoded[i]];
            if (value === undefined) {
                return null;
            }
            var carry = value;
            var bytesLen = bytes.length;
            for (var j = 0; j < bytesLen; j += 1) {
                carry += bytes[j] * BASE;
                bytes[j] = carry & 0xff;
                carry >>= 8;
            }
            while (carry > 0) {
                bytes.push(carry & 0xff);
                carry >>= 8;
            }
        }
        var lastStrIndex = encoded.length - 1;
        for (var k = 0; encoded[k] === LEADER && k < lastStrIndex; k += 1) {
            bytes.push(0);
        }
        return Buffer.from(bytes.reverse());
    };
    var encode = function (str, encoding) {
        if (encoding === void 0) { encoding = defaultEncoding; }
        return encodeFromBuffer(Buffer.from(str, encoding));
    };
    var decode = function (encoded, encoding) {
        if (encoding === void 0) { encoding = defaultEncoding; }
        var buffer = decodeToBuffer(encoded);
        return buffer && buffer.toString(encoding);
    };
    return {
        encode: encode,
        decode: decode,
        encodeFromBuffer: encodeFromBuffer,
        decodeToBuffer: decodeToBuffer,
    };
};
//# sourceMappingURL=index.js.map